# A tool to ensure that the pull requests is correctly formatted for changelog and semantic release
name: tool-pr-version-calculate

on:
  workflow_call:
    inputs:
      python_version:
        description: "Python version"
        type: string
        required: false
        default: "3.11"
      config_toml_data:
        description: "Toml config file data for actions base64 encoded"
        type: string
        required: false
        default: ""
      config_toml_file:
        description: "config file in repo for actions"
        type: string
        required: false
        default: "action_config.toml"
    outputs:
      calculated_version:
        description: "Calculated version"
        value: ${{ jobs.version_calc.outputs.calculated_version }}
      release_override_found:
        description: "Release override found"
        value: ${{ jobs.version_calc.outputs.release_override_found }}
      is_release:
        description: "Is set to 'true' if its a release"
        value: ${{ jobs.version_calc.outputs.is_release }}
    secrets:
      SOURCE_KEY:
        required: false

permissions:
  pull-requests: read
  contents: read

jobs:
  version_calc:
    name: Calculate semantic release version
    runs-on: ubuntu-latest
    outputs:
      calculated_version: ${{ steps.calculate_version.outputs.new_version }}
      release_override_found: ${{ steps.calculate_version.outputs.release_override_found }}
      is_release: ${{ steps.calculate_version.outputs.is_release }}
    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }} # we don't need the PR head sha, we need the base sha to calculate the next version
          fetch-depth: 0

      - name: Add current title as commit for semantic release calculation
        run: |
          git config --global user.email "dummy@dummy.com"
          git config --global user.name "dummy"
          git commit --allow-empty -m "${{ github.event.pull_request.title }}"
          echo "LATEST_RELEASE_TAG=$(git describe --tags --abbrev=0)" >> $GITHUB_ENV

      - name: Set up Python ${{ inputs.python_version }}
        uses: actions/setup-python@v3
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install toml==0.10.2 python-semantic-release==8.1.1

      - name: Check the calculated version from semantic release
        shell: python
        id: calculate_version
        env:
          LABELS: ${{ toJson(github.event.pull_request.labels.*.name) }}
        run: |
          import subprocess
          import os
          import json
          import base64

          def deserialize_str(s):
            return base64.b64decode(s).decode('utf-8')

          def set_output(name, value):
            with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                print(f'{name}={value}', file=fh)

          # Get up-to-date action_config.toml data from incoming PR branch.
          toml_data = json.loads(deserialize_str(b"${{ inputs.config_toml_data }}"))

          label_names = json.loads(os.environ['LABELS'])
          rel_labels = [l for l in label_names if l.startswith('release-')]
          if len(rel_labels) == 0:
            rel_labels.append('release-skip')

          # Command to execute
          command = ["semantic-release", "--config", "${{ inputs.config_toml_file }}", "--noop", "version"]


          # verify labels and only run version calculation if its a release
          # if skip we do not return any version/set is_release to true
          # if more then one label we do not return any version//set is_release to true

          release_label_map = {
              "release-skip": "",
              "release-auto": "",
              "release-patch": "--patch",
              "release-minor": "--minor",
              "release-major": "--major"
          }

          def check_label(label_name, cur_count, cur_label, cur_force_release):
              if label_name in release_label_map:
                  return (cur_count + 1, label_name, release_label_map[label_name])
              return (cur_count, cur_label, cur_force_release)

          # defaults
          release_labels_found = 0
          release_label = "release-skip"
          forced_release = ""

          for label in rel_labels:
              (release_labels_found, release_label, forced_release) = check_label(
                  label, release_labels_found, release_label, forced_release)

          # temp debug..
          print(rel_labels)
          print(release_labels_found)
          print(release_label)
          print(forced_release)
          print("${{ env.LATEST_RELEASE_TAG }}")

          if release_labels_found != 1:
            # exit, if multible is set, then something is wrong and we really do not want to do any release
            exit()

          if release_label == "release-skip":
            # exit if skip release
            exit()

          if forced_release != "":
            command.append(forced_release)

          # debug print
          print(command)      

          # Running the command and capturing output
          result = subprocess.run(command, capture_output=True, text=True)

          # Extracting the output
          output = result.stdout.strip()

          # print any errors
          if result.stderr:
              print(result.stderr)

          # The version name should be in the output
          print(f'Captured Version Name: "{output}"')

          # Compare current tag with new so we know if its new

          cur_version = "${{ env.LATEST_RELEASE_TAG }}"
          new_version = f"v{output}"

          # debug print
          print(cur_version)
          print(new_version)

          if cur_version != new_version:
            set_output('new_version', str(output))
            set_output('release_override_found', forced_release)
            set_output('is_release', "true")
