name: tool-review-docker
on:
  workflow_call:
    inputs:
      python_version:
        description: 'Python version'
        type: string
        required: false
        default: '3.11'
      branch:
        description: "pr branch"
        type: string
      push_docker:
        description: 'Push docker image'
        type: string
        required: false
        default: "false"
      docker_use_latest:
        description: 'Push docker image with latest tag'
        type: string
        required: false
        default: false
      docker_tag_override:
        description: 'Override docker tag'
        type: string
        required: false
        default: ''
      create_build_logs:
        description: 'Create build logs (for testing only)'
        type: string
        required: false
        default: false
      docker_matrix:
        description: 'Docker matrix'
        type: string
        required: false
        default: ''
      config_toml_data:
        description: "Toml config file for actions base64 encoded"
        type: string
        required: false
        default: ""
    outputs:
      docker_review_str:
        description: 'Body of the comment'
        value: ${{ jobs.docker_review.outputs.docker_review_str }}
      docker_review_ok:
        description: 'Is the PR ok'
        value: ${{ jobs.docker_review.outputs.docker_review_ok }}
      build_logs_str:
        description: 'Build logs'
        value: ${{ jobs.summarize_build_logs.outputs.build_log_summary }}
    secrets:
      CONTAINER_REGISTRY_URL:
        required: false
      CONTAINER_REGISTRY_USERNAME:
        required: false
      CONTAINER_REGISTRY_PASSWORD:
        required: false

env:
  IS_PRE_RELEASE: 'false'
  BUILD_LOG_DIR: ${{ github.workspace }}

jobs:
  load-config:
    uses: ./.github/workflows/tool-load-config.yaml
    with:
      branch: ${{ inputs.branch }}

  docker_prep:
    name: Docker Secrets and Login Check
    runs-on: ubuntu-latest
    outputs:
      registry_login_success: ${{ steps.registry_login.outputs.login_success }}
      has_registry_url: ${{ steps.secrets_check.outputs.has_registry_url }}
      has_registry_username: ${{ steps.secrets_check.outputs.has_registry_username }}
      has_registry_password: ${{ steps.secrets_check.outputs.has_registry_password }}
    steps:
      - name: Checkout Source
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install toml==0.10.2

      - name: Check for existence of required secrets
        id: secrets_check
        run: |
          if [ -z "${{ secrets.CONTAINER_REGISTRY_URL }}" ]; then
            echo "CONTAINER_REGISTRY_URL is not set as a secret"
            echo "has_registry_url=false" >> $GITHUB_OUTPUT
          else
            echo "has_registry_url=true" >> $GITHUB_OUTPUT
          fi
          
          if [ -z "${{ secrets.CONTAINER_REGISTRY_USERNAME }}" ]; then
            echo "CONTAINER_REGISTRY_USERNAME is not set as a secret"
            echo "has_registry_username=false" >> $GITHUB_OUTPUT
          else
            echo "has_registry_username=true" >> $GITHUB_OUTPUT
          fi
          
          if [ -z "${{ secrets.CONTAINER_REGISTRY_PASSWORD }}" ]; then
            echo "CONTAINER_REGISTRY_PASSWORD is not set as a secret"
            echo "has_registry_password=false" >> $GITHUB_OUTPUT
          else
            echo "has_registry_password=true" >> $GITHUB_OUTPUT
          fi

      - name: Check if registry login is setup correctly
        continue-on-error: true
        id: registry_login
        run: |
          echo ${{ secrets.CONTAINER_REGISTRY_PASSWORD }} | docker login ${{ secrets.CONTAINER_REGISTRY_URL }} -u ${{ secrets.CONTAINER_REGISTRY_USERNAME }} --password-stdin
          echo "login_success=true" >> $GITHUB_OUTPUT


  docker_build_tests:
    needs: load-config
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson( inputs.docker_matrix ) }}
    steps:
      - name: Check if matrix.docker.enabled is true
        run: |
          if [[ "${{ matrix.docker.enabled }}" == "false" ]]; then
            echo "Docker is disabled for this tool"
            echo "DOCKER_DISABLED=true" >> $GITHUB_ENV
          fi
      
      - name: Checkout git
        if: env.DOCKER_DISABLED != 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha || github.ref }}

      - uses: actions/setup-python@v5
        if: env.DOCKER_DISABLED != 'true'
        with:
          python-version: ${{ inputs.python_version }}

      - name: Install deps
        if: env.DOCKER_DISABLED != 'true'
        run: |
          pip install --upgrade pip
          pip install toml==0.10.2

      - name: Check if release override contains "next"
        if: env.DOCKER_DISABLED != 'true'
        id: check_release_override
        env:
          INPUT_DOCKER_TAG_OVERRIDE: ${{ inputs.docker_tag_override }}
        shell: python
        run: |
          import os
            
          def set_env(name, value):
            with open(os.environ['GITHUB_ENV'], 'a') as fh:
                print(f'{name}={value}', file=fh)
            
          release_override = os.getenv('INPUT_DOCKER_TAG_OVERRIDE')
          print(f"{release_override=}")
            
          if 'next.' in release_override:
              print("IS_PRE_RELEASE=true")
              set_env('IS_PRE_RELEASE', 'true')
          else:
              print("IS_PRE_RELEASE=false")
              set_env('IS_PRE_RELEASE', 'false')

      - name: Update csharp-release.toml on pre-release
        if: env.IS_PRE_RELEASE == 'true' && env.DOCKER_DISABLED != 'true'
        env:
          INPUT_DOCKER_TAG_OVERRIDE: ${{ inputs.docker_tag_override }}
        shell: python
        run: |
            import os
            import pathlib
            import toml
            import json
            
            def set_env(name, value):
                with open(os.environ['GITHUB_ENV'], 'a') as fh:
                    print(f'{name}={value}', file=fh)
            
            csharp_tomls = list(pathlib.Path('').rglob('csharp-release.toml'))
            package_jsons = list(pathlib.Path('').rglob('package.json'))
            version_override = os.getenv('INPUT_DOCKER_TAG_OVERRIDE')
            print(f"{version_override=}")
            
            # Check if csharp-release.toml.toml exists
            if len(csharp_tomls) > 0:
                print("Found csharp-release.toml")
                csharp_toml = csharp_tomls[0]
                print(f"{csharp_toml=}")
                
                # Read csharp-release.toml
                with open(csharp_toml, 'r') as file:
                    toml_data = toml.load(file)
                
                # Update csharp-release.toml
              
                # replace next. with next to comply with PEP440
                cs_version_override = version_override.replace('-next.', 'dev')
                print(f"{cs_version_override=}")
                toml_data['project']['version'] = cs_version_override
                
                # Write csharp-release.toml
                with open(csharp_toml, 'w') as file:
                    toml.dump(toml_data, file)
                print(toml_data)
            
            # Check if package.json exists
            if len(package_jsons) > 0:
                print("Found package.json")
                for package_json in package_jsons:
                  print(f"Updating {package_json=}")
                  
                  # Read package.json
                  with open(package_json, 'r') as file:
                      json_data = json.load(file)
                  
                  # Update package.json
                  json_data['version'] = os.getenv('INPUT_DOCKER_TAG_OVERRIDE')
                  
                  # Write package.json
                  with open(package_json, 'w') as file:
                      json.dump(json_data, file)

      - name: Build docker image with ${{ steps.set_release_tag.outputs.docker_tag }} tag
        if: inputs.create_build_logs == 'false' && env.DOCKER_DISABLED != 'true'
        run: |
          docker build -f ${{ matrix.docker.context }}/${{ matrix.docker.docker_file }} -t ${{ secrets.CONTAINER_REGISTRY_URL }}/${{ matrix.docker.team_name }}/${{ matrix.docker.image_name }}:${{ inputs.docker_tag_override }} ${{ matrix.docker.context }}

      - name: Build docker image with latest tag
        if: ( matrix.docker.use_latest == true || inputs.create_build_logs == 'true') && env.DOCKER_DISABLED != 'true'
        run: |
          docker build -f ${{ matrix.docker.context }}/${{ matrix.docker.docker_file }} -t ${{ secrets.CONTAINER_REGISTRY_URL }}/${{ matrix.docker.team_name }}/${{ matrix.docker.image_name }}:latest ${{ matrix.docker.context }}
          # if inputs.create_build_logs == 'true' then we will echo to file
          if [[ "${{ inputs.create_build_logs }}" == "true" ]]; then
            # Create a file with the build log. File name should have the github action run id in it to avoid collisions
            echo "${{ matrix.docker.ref_name }}" >> build_log_docker_${{ github.run_id }}_${{ matrix.docker.ref_name }}.txt
          fi

      - name: Upload Build Log
        if: inputs.create_build_logs == 'true' && env.DOCKER_DISABLED != 'true'
        uses: actions/upload-artifact@v4
        continue-on-error: true # Needed to continue in the event the build fails and no build log is found
        with:
          name: build-log-docker-${{ github.run_id }}-${{ matrix.docker.ref_name }}
          path: build_log_docker_${{ github.run_id }}_${{ matrix.docker.ref_name }}.txt
          overwrite: true
     
      
      - name: Source - login to ACR
        if: inputs.push_docker == 'true' && env.DOCKER_DISABLED != 'true'
        uses: docker/login-action@v3.0.0
        with:
          registry: ${{ secrets.CONTAINER_REGISTRY_URL }}
          username: ${{ secrets.CONTAINER_REGISTRY_USERNAME }}
          password: ${{ secrets.CONTAINER_REGISTRY_PASSWORD }}

      - name: Push docker image with ${{ inputs.docker_tag_override }} tag
        if: inputs.push_docker == 'true' && env.DOCKER_DISABLED != 'true'
        run: |
          docker push ${{ secrets.CONTAINER_REGISTRY_URL }}/${{ matrix.docker.team_name }}/${{ matrix.docker.image_name }}:${{ inputs.docker_tag_override }}

      - name: Push docker image with latest tag
        if: matrix.docker.use_latest == true && inputs.push_docker == 'true' && env.DOCKER_DISABLED != 'true'
        run: |
          docker push ${{ secrets.CONTAINER_REGISTRY_URL }}/${{ matrix.docker.team_name }}/${{ matrix.docker.image_name }}:latest

  summarize_build_logs:
    if: inputs.create_build_logs == 'true'
    needs: docker_build_tests
    runs-on: ubuntu-latest
    outputs:
      build_log_summary: ${{ steps.summarize_build_logs.outputs.build_log_summary }}
    steps:
      - name: Download Build Log Artifact
        uses: actions/download-artifact@v4
        with:
          pattern: build-log-docker-${{ github.run_id }}-*  # Download the build log artifact
          merge-multiple: true
          path: ${{ env.BUILD_LOG_DIR }}

      - name: Review Build Logs and
        id: summarize_build_logs  # Set an ID for this step to reference its outputs
        shell: python
        run: |
          import os
          import pathlib
          import base64

          def set_output(name, value, encode_it=False):
            if encode_it:
              value = base64.b64encode(value.encode('utf-8')).decode('utf-8')
            with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                print(f'{name}={value}', file=fh)

          # Check if docker build was successful or not
          build_logs = ""
          for p in pathlib.Path(os.environ["BUILD_LOG_DIR"]).glob('build_log_docker_*.txt'):
            with open(p, 'r') as file:
              build_logs += file.read().strip()
              build_logs += ";"
            
          set_output('build_log_summary', build_logs)

  docker_review:
    runs-on: ubuntu-latest
    needs: [ load-config, docker_prep, docker_build_tests, summarize_build_logs ]
    if: always()
    outputs:
      docker_review_str: ${{ steps.comment_body.outputs.body }}
      docker_review_ok: ${{ steps.comment_body.outputs.docker_review_ok }}
    steps:
      - name: Review Docker config and create body for comment
        id: comment_body  # Set an ID for this step to reference its outputs
        env:
          DOCKER_MATRIX_STR: ${{ needs.load-config.outputs.docker_matrix }}
        shell: python
        run: |
          import os
          import pathlib
          import base64
          import json

          def set_output(name, value, encode_it=False):
            if encode_it:
              value = base64.b64encode(value.encode('utf-8')).decode('utf-8')
            with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
                print(f'{name}={value}', file=fh)
          
          # Check if the registry_login was successful or not
          has_registry_login = '${{ needs.docker_prep.outputs.registry_login_success }}' == 'true'
          
          # Check if docker build was successful or not
          # build_logs = "${{ needs.docker_build_tests.outputs.build_logs_str }}".split(";")
          build_logs = "${{ needs.summarize_build_logs.outputs.build_log_summary }}".split(";")
          
          # Remove empty strings
          build_logs = [x for x in build_logs if x]
          
          print("Build Log:", build_logs)
          docker_matrix = json.loads(os.environ['DOCKER_MATRIX_STR'])["docker"]
          docker_images = [x["ref_name"] for x in docker_matrix if x["enabled"]]
          
          print("Docker Images:", docker_images)
          
          # Compare build_logs and docker_images and ensure that they are equal disregarding order
          has_docker_build = set(docker_images) == set(build_logs)
          print("has_docker_build:", has_docker_build)
          
          # Check if all secrets are set         
          has_registry_url = '${{ needs.docker_prep.outputs.has_registry_url }}' == 'true'
          has_registry_username = '${{ needs.docker_prep.outputs.has_registry_username }}' == 'true'
          has_registry_password = '${{ needs.docker_prep.outputs.has_registry_password }}' == 'true'
          
          all_checks = [has_registry_login, has_registry_url, has_registry_username, has_registry_password, has_docker_build]
          
          # Docker Review results
          body = "\n# Docker Review:\n\n"
          
          if all(all_checks):
            body += "I found no docker-related issues.\n"
            set_output('docker_review_ok', 'true')
          else:
            body += "I found some docker-related issues:\n\n"
            set_output('docker_review_ok', 'false')
          
          if has_registry_url:
            body += "* ✅ I found the CONTAINER_REGISTRY_URL secret.\n"
          else:
            body += "* ❌ I did not find the CONTAINER_REGISTRY_URL secret.\n"
          
          if has_registry_username:
            body += "* ✅ I found the CONTAINER_REGISTRY_USERNAME secret.\n"
          else:
            body += "* ❌ I did not find the CONTAINER_REGISTRY_USERNAME secret.\n"
          
          if has_registry_password:
            body += "* ✅ I found the CONTAINER_REGISTRY_PASSWORD secret.\n"
          else:
            body += "* ❌ I did not find the CONTAINER_REGISTRY_PASSWORD secret.\n"
          
          if has_registry_login:
            body += "* ✅ I was able to login to the Container Registry.\n"
          else:
            body += "* ❌ I was not able to login to the Container Registry.\n"
          
          if has_docker_build:
            body += "* ✅ I was able to build the docker image(s).\n"
          else:
            body += "* ❌ I was not able to build the docker image(s).\n"
            for image in docker_images:
              if image not in build_logs:
                body += f'  * ❌ I was not able to build the docker image: "{image}"\n'
              else:
                body += f'  * ✅ I was able to build the docker image: "{image}"\n'
          
          # Set the output
          set_output('body', body, True)
          print(body)